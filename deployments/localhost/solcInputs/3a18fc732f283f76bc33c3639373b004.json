{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/defifranc/interfaces/IActivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\nimport \"./IPool.sol\";\r\n\r\ninterface IActivePool is IPool {\r\n    // --- Events ---\r\n    event BorrowerOperationsAddressChanged(\r\n        address _newBorrowerOperationsAddress\r\n    );\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolDCHFDebtUpdated(address _asset, uint256 _DCHFDebt);\r\n    event ActivePoolAssetBalanceUpdated(address _asset, uint256 _balance);\r\n\r\n    // --- Functions ---\r\n    function sendAsset(\r\n        address _asset,\r\n        address _account,\r\n        uint256 _amount\r\n    ) external;\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\n// Common interface for the Trove Manager.\r\ninterface IBorrowerOperations {\r\n    // --- Events ---\r\n\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\r\n    event GasPoolAddressChanged(address _gasPoolAddress);\r\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event DCHFTokenAddressChanged(address _dchfTokenAddress);\r\n    event MONStakingAddressChanged(address _MONStakingAddress);\r\n\r\n    event TroveCreated(\r\n        address indexed _asset,\r\n        address indexed _borrower,\r\n        uint256 arrayIndex\r\n    );\r\n    event TroveUpdated(\r\n        address indexed _asset,\r\n        address indexed _borrower,\r\n        uint256 _debt,\r\n        uint256 _coll,\r\n        uint256 stake,\r\n        uint8 operation\r\n    );\r\n    event DCHFBorrowingFeePaid(\r\n        address indexed _asset,\r\n        address indexed _borrower,\r\n        uint256 _DCHFFee\r\n    );\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses(\r\n        address _troveManagerAddress,\r\n        address _troveManagerHelpersAddress,\r\n        address _stabilityPoolAddress,\r\n        address _gasPoolAddress,\r\n        address _collSurplusPoolAddress,\r\n        address _sortedTrovesAddress,\r\n        address _dchfTokenAddress,\r\n        address _MONStakingAddress,\r\n        address _dfrancParamsAddress\r\n    ) external;\r\n\r\n    function openTrove(\r\n        address _asset,\r\n        uint256 _tokenAmount,\r\n        uint256 _maxFee,\r\n        uint256 _DCHFamount,\r\n        address _upperHint,\r\n        address _lowerHint\r\n    ) external payable;\r\n\r\n    function addColl(\r\n        address _asset,\r\n        uint256 _assetSent,\r\n        address _upperHint,\r\n        address _lowerHint\r\n    ) external payable;\r\n\r\n    function moveETHGainToTrove(\r\n        address _asset,\r\n        uint256 _amountMoved,\r\n        address _user,\r\n        address _upperHint,\r\n        address _lowerHint\r\n    ) external payable;\r\n\r\n    function withdrawColl(\r\n        address _asset,\r\n        uint256 _amount,\r\n        address _upperHint,\r\n        address _lowerHint\r\n    ) external;\r\n\r\n    function withdrawDCHF(\r\n        address _asset,\r\n        uint256 _maxFee,\r\n        uint256 _amount,\r\n        address _upperHint,\r\n        address _lowerHint\r\n    ) external;\r\n\r\n    function repayDCHF(\r\n        address _asset,\r\n        uint256 _amount,\r\n        address _upperHint,\r\n        address _lowerHint\r\n    ) external;\r\n\r\n    function closeTrove(address _asset) external;\r\n\r\n    function adjustTrove(\r\n        address _asset,\r\n        uint256 _assetSent,\r\n        uint256 _maxFee,\r\n        uint256 _collWithdrawal,\r\n        uint256 _debtChange,\r\n        bool isDebtIncrease,\r\n        address _upperHint,\r\n        address _lowerHint\r\n    ) external payable;\r\n\r\n    function claimCollateral(address _asset) external;\r\n\r\n    function getCompositeDebt(address _asset, uint256 _debt)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function isContractBorrowerOps() external pure returns (bool);\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/ICollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"./IDeposit.sol\";\r\n\r\ninterface ICollSurplusPool is IDeposit {\r\n    // --- Events ---\r\n\r\n    event BorrowerOperationsAddressChanged(\r\n        address _newBorrowerOperationsAddress\r\n    );\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n\r\n    event CollBalanceUpdated(address indexed _account, uint256 _newBalance);\r\n    event AssetSent(address _to, uint256 _amount);\r\n\r\n    // --- Contract setters ---\r\n\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _troveManagerAddress,\r\n        address _troveManagerHelpersAddress,\r\n        address _activePoolAddress\r\n    ) external;\r\n\r\n    function getAssetBalance(address _asset) external view returns (uint256);\r\n\r\n    function getCollateral(address _asset, address _account)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function accountSurplus(\r\n        address _asset,\r\n        address _account,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    function claimColl(address _asset, address _account) external;\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/IDCHFToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\nimport \"../../token/ERC20Permit.sol\";\r\nimport \"./IStabilityPoolManager.sol\";\r\n\r\nabstract contract IDCHFToken is ERC20Permit {\r\n    // --- Events ---\r\n\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n\r\n    event DCHFTokenBalanceUpdated(address _user, uint256 _amount);\r\n\r\n    function emergencyStopMinting(address _asset, bool status) external virtual;\r\n\r\n    function addTroveManager(address _troveManager) external virtual;\r\n\r\n    function removeTroveManager(address _troveManager) external virtual;\r\n\r\n    function addBorrowerOps(address _borrowerOps) external virtual;\r\n\r\n    function removeBorrowerOps(address _borrowerOps) external virtual;\r\n\r\n    function mint(\r\n        address _asset,\r\n        address _account,\r\n        uint256 _amount\r\n    ) external virtual;\r\n\r\n    function burn(address _account, uint256 _amount) external virtual;\r\n\r\n    function sendToPool(\r\n        address _sender,\r\n        address poolAddress,\r\n        uint256 _amount\r\n    ) external virtual;\r\n\r\n    function returnFromPool(\r\n        address poolAddress,\r\n        address user,\r\n        uint256 _amount\r\n    ) external virtual;\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/IDefaultPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\nimport \"./IPool.sol\";\r\n\r\ninterface IDefaultPool is IPool {\r\n    // --- Events ---\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event DefaultPoolDCHFDebtUpdated(address _asset, uint256 _DCHFDebt);\r\n    event DefaultPoolAssetBalanceUpdated(address _asset, uint256 _balance);\r\n\r\n    // --- Functions ---\r\n    function sendAssetToActivePool(address _asset, uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/IDeposit.sol": {
      "content": "pragma solidity ^0.8.14;\r\n\r\ninterface IDeposit {\r\n    function receivedERC20(address _asset, uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/IDfrancBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\nimport \"./IDfrancParameters.sol\";\r\n\r\ninterface IDfrancBase {\r\n    event VaultParametersBaseChanged(address indexed newAddress);\r\n\r\n    function dfrancParams() external view returns (IDfrancParameters);\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/IDfrancParameters.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\nimport \"./IActivePool.sol\";\r\nimport \"./IDefaultPool.sol\";\r\nimport \"./IPriceFeed.sol\";\r\nimport \"./IDfrancBase.sol\";\r\n\r\ninterface IDfrancParameters {\r\n    error SafeCheckError(\r\n        string parameter,\r\n        uint256 valueEntered,\r\n        uint256 minValue,\r\n        uint256 maxValue\r\n    );\r\n\r\n    event MCRChanged(uint256 oldMCR, uint256 newMCR);\r\n    event CCRChanged(uint256 oldCCR, uint256 newCCR);\r\n    event GasCompensationChanged(uint256 oldGasComp, uint256 newGasComp);\r\n    event MinNetDebtChanged(uint256 oldMinNet, uint256 newMinNet);\r\n    event PercentDivisorChanged(uint256 oldPercentDiv, uint256 newPercentDiv);\r\n    event BorrowingFeeFloorChanged(\r\n        uint256 oldBorrowingFloorFee,\r\n        uint256 newBorrowingFloorFee\r\n    );\r\n    event MaxBorrowingFeeChanged(\r\n        uint256 oldMaxBorrowingFee,\r\n        uint256 newMaxBorrowingFee\r\n    );\r\n    event RedemptionFeeFloorChanged(\r\n        uint256 oldRedemptionFeeFloor,\r\n        uint256 newRedemptionFeeFloor\r\n    );\r\n    event RedemptionBlockRemoved(address _asset);\r\n    event PriceFeedChanged(address indexed addr);\r\n\r\n    function DECIMAL_PRECISION() external view returns (uint256);\r\n\r\n    function _100pct() external view returns (uint256);\r\n\r\n    // Minimum collateral ratio for individual troves\r\n    function MCR(address _collateral) external view returns (uint256);\r\n\r\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\r\n    function CCR(address _collateral) external view returns (uint256);\r\n\r\n    function DCHF_GAS_COMPENSATION(address _collateral)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function MIN_NET_DEBT(address _collateral) external view returns (uint256);\r\n\r\n    function PERCENT_DIVISOR(address _collateral)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function BORROWING_FEE_FLOOR(address _collateral)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function REDEMPTION_FEE_FLOOR(address _collateral)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function MAX_BORROWING_FEE(address _collateral)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function redemptionBlock(address _collateral)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function activePool() external view returns (IActivePool);\r\n\r\n    function defaultPool() external view returns (IDefaultPool);\r\n\r\n    function priceFeed() external view returns (IPriceFeed);\r\n\r\n    function setAddresses(\r\n        address _activePool,\r\n        address _defaultPool,\r\n        address _priceFeed,\r\n        address _adminContract\r\n    ) external;\r\n\r\n    function setPriceFeed(address _priceFeed) external;\r\n\r\n    function setMCR(address _asset, uint256 newMCR) external;\r\n\r\n    function setCCR(address _asset, uint256 newCCR) external;\r\n\r\n    function sanitizeParameters(address _asset) external;\r\n\r\n    function setAsDefault(address _asset) external;\r\n\r\n    function setAsDefaultWithRemptionBlock(address _asset, uint256 blockInDays)\r\n        external;\r\n\r\n    function setDCHFGasCompensation(address _asset, uint256 gasCompensation)\r\n        external;\r\n\r\n    function setMinNetDebt(address _asset, uint256 minNetDebt) external;\r\n\r\n    function setPercentDivisor(address _asset, uint256 precentDivisor) external;\r\n\r\n    function setBorrowingFeeFloor(address _asset, uint256 borrowingFeeFloor)\r\n        external;\r\n\r\n    function setMaxBorrowingFee(address _asset, uint256 maxBorrowingFee)\r\n        external;\r\n\r\n    function setRedemptionFeeFloor(address _asset, uint256 redemptionFeeFloor)\r\n        external;\r\n\r\n    function removeRedemptionBlock(address _asset) external;\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/IHintHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\ninterface IHintHelpers {\r\n    struct LocalRedemptionVars {\r\n        address _asset;\r\n        uint256 _DCHFamount;\r\n        uint256 _pricel;\r\n        uint256 _maxIterations;\r\n    }\r\n\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event TroveManagerAddressChanged(address _troveManagerAddress);\r\n\r\n    function getRedemptionHints(\r\n        address _asset,\r\n        uint256 _DCHFamount,\r\n        uint256 _price,\r\n        uint256 _maxIterations\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address firstRedemptionHint,\r\n            uint256 partialRedemptionHintNICR,\r\n            uint256 truncatedDCHFamount\r\n        );\r\n\r\n    function getApproxHint(\r\n        address _asset,\r\n        uint256 _CR,\r\n        uint256 _numTrials,\r\n        uint256 _inputRandomSeed\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address hintAddress,\r\n            uint256 diff,\r\n            uint256 latestRandomSeed\r\n        );\r\n\r\n    function computeNominalCR(uint256 _coll, uint256 _debt)\r\n        external\r\n        pure\r\n        returns (uint256);\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/IMONStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ninterface IMONStaking {\r\n    // --- Events --\r\n\r\n    event TreasuryAddressChanged(address _treausury);\r\n    event SentToTreasury(address indexed _asset, uint256 _amount);\r\n    event MONTokenAddressSet(address _MONTokenAddress);\r\n    event DCHFTokenAddressSet(address _dchfTokenAddress);\r\n    event TroveManagerAddressSet(address _troveManager);\r\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\r\n    event ActivePoolAddressSet(address _activePoolAddress);\r\n\r\n    event StakeChanged(address indexed staker, uint256 newStake);\r\n    event StakingGainsAssetWithdrawn(\r\n        address indexed staker,\r\n        address indexed asset,\r\n        uint256 AssetGain\r\n    );\r\n    event StakingGainsDCHFWithdrawn(address indexed staker, uint256 DCHFGain);\r\n    event F_AssetUpdated(address indexed _asset, uint256 _F_ASSET);\r\n    event F_DCHFUpdated(uint256 _F_DCHF);\r\n    event TotalMONStakedUpdated(uint256 _totalMONStaked);\r\n    event AssetSent(\r\n        address indexed _asset,\r\n        address indexed _account,\r\n        uint256 _amount\r\n    );\r\n    event StakerSnapshotsUpdated(\r\n        address _staker,\r\n        uint256 _F_Asset,\r\n        uint256 _F_DCHF\r\n    );\r\n\r\n    function monToken() external view returns (IERC20);\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses(\r\n        address _MONTokenAddress,\r\n        address _dchfTokenAddress,\r\n        address _troveManagerAddress,\r\n        address _troveManagerHelpersAddress,\r\n        address _borrowerOperationsAddress,\r\n        address _activePoolAddress,\r\n        address _treasury\r\n    ) external;\r\n\r\n    function stake(uint256 _MONamount) external;\r\n\r\n    function unstake(uint256 _MONamount) external;\r\n\r\n    function increaseF_Asset(address _asset, uint256 _AssetFee) external;\r\n\r\n    function increaseF_DCHF(uint256 _MONFee) external;\r\n\r\n    function getPendingAssetGain(address _asset, address _user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getPendingDCHFGain(address _user) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"./IDeposit.sol\";\r\n\r\n// Common interface for the Pools.\r\ninterface IPool is IDeposit {\r\n    // --- Events ---\r\n\r\n    event AssetBalanceUpdated(uint256 _newBalance);\r\n    event DCHFBalanceUpdated(uint256 _newBalance);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    event AssetAddressChanged(address _assetAddress);\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n    event AssetSent(address _to, address indexed _asset, uint256 _amount);\r\n\r\n    // --- Functions ---\r\n\r\n    function getAssetBalance(address _asset) external view returns (uint256);\r\n\r\n    function getDCHFDebt(address _asset) external view returns (uint256);\r\n\r\n    function increaseDCHFDebt(address _asset, uint256 _amount) external;\r\n\r\n    function decreaseDCHFDebt(address _asset, uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\npragma solidity ^0.8.14;\r\n\r\ninterface IPriceFeed {\r\n    struct ChainlinkResponse {\r\n        uint80 roundId;\r\n        int256 answer;\r\n        uint256 timestamp;\r\n        bool success;\r\n        uint8 decimals;\r\n    }\r\n\r\n    struct RegisterOracle {\r\n        AggregatorV3Interface chainLinkOracle;\r\n        AggregatorV3Interface chainLinkIndex;\r\n        bool isRegistered;\r\n    }\r\n\r\n    enum Status {\r\n        chainlinkWorking,\r\n        chainlinkUntrusted\r\n    }\r\n\r\n    // --- Events ---\r\n    event PriceFeedStatusChanged(Status newStatus);\r\n    event LastGoodPriceUpdated(address indexed token, uint256 _lastGoodPrice);\r\n    event LastGoodIndexUpdated(address indexed token, uint256 _lastGoodIndex);\r\n    event RegisteredNewOracle(\r\n        address token,\r\n        address chainLinkAggregator,\r\n        address chianLinkIndex\r\n    );\r\n\r\n    // --- Function ---\r\n    function addOracle(\r\n        address _token,\r\n        address _chainlinkOracle,\r\n        address _chainlinkIndexOracle\r\n    ) external;\r\n\r\n    function fetchPrice(address _token) external returns (uint256);\r\n\r\n    function getDirectPrice(address _asset) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/ISortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\n// Common interface for the SortedTroves Doubly Linked List.\r\ninterface ISortedTroves {\r\n    // --- Events ---\r\n\r\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\r\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\r\n    event NodeAdded(address indexed _asset, address _id, uint256 _NICR);\r\n    event NodeRemoved(address indexed _asset, address _id);\r\n\r\n    // --- Functions ---\r\n\r\n    function setParams(\r\n        address _TroveManagerAddress,\r\n        address _troveManagerHelpersAddress,\r\n        address _borrowerOperationsAddress\r\n    ) external;\r\n\r\n    function insert(\r\n        address _asset,\r\n        address _id,\r\n        uint256 _ICR,\r\n        address _prevId,\r\n        address _nextId\r\n    ) external;\r\n\r\n    function remove(address _asset, address _id) external;\r\n\r\n    function reInsert(\r\n        address _asset,\r\n        address _id,\r\n        uint256 _newICR,\r\n        address _prevId,\r\n        address _nextId\r\n    ) external;\r\n\r\n    function contains(address _asset, address _id) external view returns (bool);\r\n\r\n    function isFull(address _asset) external view returns (bool);\r\n\r\n    function isEmpty(address _asset) external view returns (bool);\r\n\r\n    function getSize(address _asset) external view returns (uint256);\r\n\r\n    function getMaxSize(address _asset) external view returns (uint256);\r\n\r\n    function getFirst(address _asset) external view returns (address);\r\n\r\n    function getLast(address _asset) external view returns (address);\r\n\r\n    function getNext(address _asset, address _id)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function getPrev(address _asset, address _id)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function validInsertPosition(\r\n        address _asset,\r\n        uint256 _ICR,\r\n        address _prevId,\r\n        address _nextId\r\n    ) external view returns (bool);\r\n\r\n    function findInsertPosition(\r\n        address _asset,\r\n        uint256 _ICR,\r\n        address _prevId,\r\n        address _nextId\r\n    ) external view returns (address, address);\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"./IDeposit.sol\";\r\n\r\ninterface IStabilityPool is IDeposit {\r\n    // --- Events ---\r\n    event StabilityPoolAssetBalanceUpdated(uint256 _newBalance);\r\n    event StabilityPoolDCHFBalanceUpdated(uint256 _newBalance);\r\n\r\n    event BorrowerOperationsAddressChanged(\r\n        address _newBorrowerOperationsAddress\r\n    );\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    event DCHFTokenAddressChanged(address _newDCHFTokenAddress);\r\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\r\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\r\n\r\n    event P_Updated(uint256 _P);\r\n    event S_Updated(uint256 _S, uint128 _epoch, uint128 _scale);\r\n    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\r\n    event EpochUpdated(uint128 _currentEpoch);\r\n    event ScaleUpdated(uint128 _currentScale);\r\n\r\n    event DepositSnapshotUpdated(\r\n        address indexed _depositor,\r\n        uint256 _P,\r\n        uint256 _S,\r\n        uint256 _G\r\n    );\r\n    event SystemSnapshotUpdated(uint256 _P, uint256 _G);\r\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\r\n    event StakeChanged(uint256 _newSystemStake, address _depositor);\r\n\r\n    event AssetGainWithdrawn(\r\n        address indexed _depositor,\r\n        uint256 _Asset,\r\n        uint256 _DCHFLoss\r\n    );\r\n    event MONPaidToDepositor(address indexed _depositor, uint256 _MON);\r\n    event AssetSent(address _to, uint256 _amount);\r\n\r\n    // --- Functions ---\r\n\r\n    function NAME() external view returns (string memory name);\r\n\r\n    /*\r\n     * Called only once on init, to set addresses of other Dfranc contracts\r\n     * Callable only by owner, renounces ownership at the end\r\n     */\r\n    function setAddresses(\r\n        address _assetAddress,\r\n        address _borrowerOperationsAddress,\r\n        address _troveManagerAddress,\r\n        address _troveManagerHelperAddress,\r\n        address _dchfTokenAddress,\r\n        address _sortedTrovesAddress,\r\n        address _communityIssuanceAddress,\r\n        address _dfrancParamsAddress\r\n    ) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend is registered or zero address\r\n     * - Sender is not a registered frontend\r\n     * - _amount is not zero\r\n     * ---\r\n     * - Triggers a MON issuance, based on time passed since the last issuance. The MON issuance is shared between *all* depositors and front ends\r\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\r\n     * - Sends depositor's accumulated gains (MON, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated MON gains to the tagged front end\r\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     */\r\n    function provideToSP(uint256 _amount) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - _amount is zero or there are no under collateralized troves left in the system\r\n     * - User has a non zero deposit\r\n     * ---\r\n     * - Triggers a MON issuance, based on time passed since the last issuance. The MON issuance is shared between *all* depositors and front ends\r\n     * - Removes the deposit's front end tag if it is a full withdrawal\r\n     * - Sends all depositor's accumulated gains (MON, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated MON gains to the tagged front end\r\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     *\r\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\r\n     */\r\n    function withdrawFromSP(uint256 _amount) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - User has a non zero deposit\r\n     * - User has an open trove\r\n     * - User has some ETH gain\r\n     * ---\r\n     * - Triggers a MON issuance, based on time passed since the last issuance. The MON issuance is shared between *all* depositors and front ends\r\n     * - Sends all depositor's MON gain to  depositor\r\n     * - Sends all tagged front end's MON gain to the tagged front end\r\n     * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\r\n     * - Leaves their compounded deposit in the Stability Pool\r\n     * - Updates snapshots for deposit and tagged front end stake\r\n     */\r\n    function withdrawAssetGainToTrove(address _upperHint, address _lowerHint)\r\n        external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Caller is TroveManager\r\n     * ---\r\n     * Cancels out the specified debt against the DCHF contained in the Stability Pool (as far as possible)\r\n     * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\r\n     * Only called by liquidation functions in the TroveManager.\r\n     */\r\n    function offset(uint256 _debt, uint256 _coll) external;\r\n\r\n    /*\r\n     * Returns the total amount of ETH held by the pool, accounted in an internal variable instead of `balance`,\r\n     * to exclude edge cases like ETH received from a self-destruct.\r\n     */\r\n    function getAssetBalance() external view returns (uint256);\r\n\r\n    /*\r\n     * Returns DCHF held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\r\n     */\r\n    function getTotalDCHFDeposits() external view returns (uint256);\r\n\r\n    /*\r\n     * Calculates the ETH gain earned by the deposit since its last snapshots were taken.\r\n     */\r\n    function getDepositorAssetGain(address _depositor)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Calculate the MON gain earned by a deposit since its last snapshots were taken.\r\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\r\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\r\n     * which they made their deposit.\r\n     */\r\n    function getDepositorMONGain(address _depositor)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Return the user's compounded deposit.\r\n     */\r\n    function getCompoundedDCHFDeposit(address _depositor)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Return the front end's compounded stake.\r\n     *\r\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\r\n     */\r\n    function getCompoundedTotalStake() external view returns (uint256);\r\n\r\n    function getNameBytes() external view returns (bytes32);\r\n\r\n    function getAssetType() external view returns (address);\r\n\r\n    /*\r\n     * Fallback function\r\n     * Only callable by Active Pool, it just accounts for ETH received\r\n     * receive() external payable;\r\n     */\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/IStabilityPoolManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\nimport \"./IStabilityPool.sol\";\r\n\r\ninterface IStabilityPoolManager {\r\n    event StabilityPoolAdded(address asset, address stabilityPool);\r\n    event StabilityPoolRemoved(address asset, address stabilityPool);\r\n\r\n    function isStabilityPool(address stabilityPool)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function addStabilityPool(address asset, address stabilityPool) external;\r\n\r\n    function getAssetStabilityPool(address asset)\r\n        external\r\n        view\r\n        returns (IStabilityPool);\r\n\r\n    function unsafeGetAssetStabilityPool(address asset)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\nimport \"./IDfrancBase.sol\";\r\nimport \"./IStabilityPool.sol\";\r\nimport \"./IDCHFToken.sol\";\r\nimport \"./IMONStaking.sol\";\r\nimport \"./ICollSurplusPool.sol\";\r\nimport \"./ISortedTroves.sol\";\r\nimport \"./IActivePool.sol\";\r\nimport \"./IDefaultPool.sol\";\r\nimport \"./IStabilityPoolManager.sol\";\r\nimport \"./ITroveManagerHelpers.sol\";\r\n\r\n// Common interface for the Trove Manager.\r\ninterface ITroveManager is IDfrancBase {\r\n    enum Status {\r\n        nonExistent,\r\n        active,\r\n        closedByOwner,\r\n        closedByLiquidation,\r\n        closedByRedemption\r\n    }\r\n\r\n    // Store the necessary data for a trove\r\n    struct Trove {\r\n        address asset;\r\n        uint256 debt;\r\n        uint256 coll;\r\n        uint256 stake;\r\n        Status status;\r\n        uint128 arrayIndex;\r\n    }\r\n\r\n    /*\r\n     * --- Variable container structs for liquidations ---\r\n     *\r\n     * These structs are used to hold, return and assign variables inside the liquidation functions,\r\n     * in order to avoid the error: \"CompilerError: Stack too deep\".\r\n     **/\r\n\r\n    struct LocalVariables_OuterLiquidationFunction {\r\n        uint256 price;\r\n        uint256 DCHFInStabPool;\r\n        bool recoveryModeAtStart;\r\n        uint256 liquidatedDebt;\r\n        uint256 liquidatedColl;\r\n    }\r\n\r\n    struct LocalVariables_InnerSingleLiquidateFunction {\r\n        uint256 collToLiquidate;\r\n        uint256 pendingDebtReward;\r\n        uint256 pendingCollReward;\r\n    }\r\n\r\n    struct LocalVariables_LiquidationSequence {\r\n        uint256 remainingDCHFInStabPool;\r\n        uint256 i;\r\n        uint256 ICR;\r\n        address user;\r\n        bool backToNormalMode;\r\n        uint256 entireSystemDebt;\r\n        uint256 entireSystemColl;\r\n    }\r\n\r\n    struct LocalVariables_AssetBorrowerPrice {\r\n        address _asset;\r\n        address _borrower;\r\n        uint256 _price;\r\n    }\r\n\r\n    struct LiquidationValues {\r\n        uint256 entireTroveDebt;\r\n        uint256 entireTroveColl;\r\n        uint256 collGasCompensation;\r\n        uint256 DCHFGasCompensation;\r\n        uint256 debtToOffset;\r\n        uint256 collToSendToSP;\r\n        uint256 debtToRedistribute;\r\n        uint256 collToRedistribute;\r\n        uint256 collSurplus;\r\n    }\r\n\r\n    struct LiquidationTotals {\r\n        uint256 totalCollInSequence;\r\n        uint256 totalDebtInSequence;\r\n        uint256 totalCollGasCompensation;\r\n        uint256 totalDCHFGasCompensation;\r\n        uint256 totalDebtToOffset;\r\n        uint256 totalCollToSendToSP;\r\n        uint256 totalDebtToRedistribute;\r\n        uint256 totalCollToRedistribute;\r\n        uint256 totalCollSurplus;\r\n    }\r\n\r\n    struct ContractsCache {\r\n        IActivePool activePool;\r\n        IDefaultPool defaultPool;\r\n        IDCHFToken dchfToken;\r\n        IMONStaking monStaking;\r\n        ISortedTroves sortedTroves;\r\n        ICollSurplusPool collSurplusPool;\r\n        address gasPoolAddress;\r\n    }\r\n    // --- Variable container structs for redemptions ---\r\n\r\n    struct RedemptionTotals {\r\n        uint256 remainingDCHF;\r\n        uint256 totalDCHFToRedeem;\r\n        uint256 totalAssetDrawn;\r\n        uint256 ETHFee;\r\n        uint256 ETHToSendToRedeemer;\r\n        uint256 decayedBaseRate;\r\n        uint256 price;\r\n        uint256 totalDCHFSupplyAtStart;\r\n    }\r\n\r\n    struct SingleRedemptionValues {\r\n        uint256 DCHFLot;\r\n        uint256 ETHLot;\r\n        bool cancelledPartial;\r\n    }\r\n\r\n    // --- Events ---\r\n\r\n    event Liquidation(\r\n        address indexed _asset,\r\n        uint256 _liquidatedDebt,\r\n        uint256 _liquidatedColl,\r\n        uint256 _collGasCompensation,\r\n        uint256 _DCHFGasCompensation\r\n    );\r\n    event Redemption(\r\n        address indexed _asset,\r\n        uint256 _attemptedDCHFAmount,\r\n        uint256 _actualDCHFAmount,\r\n        uint256 _AssetSent,\r\n        uint256 _AssetFee\r\n    );\r\n    event TroveUpdated(\r\n        address indexed _asset,\r\n        address indexed _borrower,\r\n        uint256 _debt,\r\n        uint256 _coll,\r\n        uint256 stake,\r\n        uint8 operation\r\n    );\r\n    event TroveLiquidated(\r\n        address indexed _asset,\r\n        address indexed _borrower,\r\n        uint256 _debt,\r\n        uint256 _coll,\r\n        uint8 operation\r\n    );\r\n    event BaseRateUpdated(address indexed _asset, uint256 _baseRate);\r\n    event LastFeeOpTimeUpdated(address indexed _asset, uint256 _lastFeeOpTime);\r\n    event TotalStakesUpdated(address indexed _asset, uint256 _newTotalStakes);\r\n    event SystemSnapshotsUpdated(\r\n        address indexed _asset,\r\n        uint256 _totalStakesSnapshot,\r\n        uint256 _totalCollateralSnapshot\r\n    );\r\n    event LTermsUpdated(\r\n        address indexed _asset,\r\n        uint256 _L_ETH,\r\n        uint256 _L_DCHFDebt\r\n    );\r\n    event TroveSnapshotsUpdated(\r\n        address indexed _asset,\r\n        uint256 _L_ETH,\r\n        uint256 _L_DCHFDebt\r\n    );\r\n    event TroveIndexUpdated(\r\n        address indexed _asset,\r\n        address _borrower,\r\n        uint256 _newIndex\r\n    );\r\n\r\n    event TroveUpdated(\r\n        address indexed _asset,\r\n        address indexed _borrower,\r\n        uint256 _debt,\r\n        uint256 _coll,\r\n        uint256 _stake,\r\n        TroveManagerOperation _operation\r\n    );\r\n    event TroveLiquidated(\r\n        address indexed _asset,\r\n        address indexed _borrower,\r\n        uint256 _debt,\r\n        uint256 _coll,\r\n        TroveManagerOperation _operation\r\n    );\r\n\r\n    enum TroveManagerOperation {\r\n        applyPendingRewards,\r\n        liquidateInNormalMode,\r\n        liquidateInRecoveryMode,\r\n        redeemCollateral\r\n    }\r\n\r\n    // --- Functions ---\r\n    function isContractTroveManager() external pure returns (bool);\r\n\r\n    function troveManagerHelpers() external view returns (ITroveManagerHelpers);\r\n\r\n    function setAddresses(\r\n        address _stabilityPoolManagerAddress,\r\n        address _gasPoolAddress,\r\n        address _collSurplusPoolAddress,\r\n        address _dchfTokenAddress,\r\n        address _sortedTrovesAddress,\r\n        address _monStakingAddress,\r\n        address _dfrancParamsAddress,\r\n        address _troveManagerHelpersAddress\r\n    ) external;\r\n\r\n    function stabilityPoolManager()\r\n        external\r\n        view\r\n        returns (IStabilityPoolManager);\r\n\r\n    function dchfToken() external view returns (IDCHFToken);\r\n\r\n    function monStaking() external view returns (IMONStaking);\r\n\r\n    function liquidate(address _asset, address borrower) external;\r\n\r\n    function liquidateTroves(address _asset, uint256 _n) external;\r\n\r\n    function batchLiquidateTroves(address _asset, address[] memory _troveArray)\r\n        external;\r\n\r\n    function redeemCollateral(\r\n        address _asset,\r\n        uint256 _DCHFamount,\r\n        address _firstRedemptionHint,\r\n        address _upperPartialRedemptionHint,\r\n        address _lowerPartialRedemptionHint,\r\n        uint256 _partialRedemptionHintNICR,\r\n        uint256 _maxIterations,\r\n        uint256 _maxFee\r\n    ) external;\r\n}\r\n"
    },
    "contracts/defifranc/interfaces/ITroveManagerHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\nimport \"./IDfrancBase.sol\";\r\nimport \"./IStabilityPool.sol\";\r\nimport \"./IDCHFToken.sol\";\r\nimport \"./IMONStaking.sol\";\r\nimport \"./ICollSurplusPool.sol\";\r\nimport \"./ISortedTroves.sol\";\r\nimport \"./IActivePool.sol\";\r\nimport \"./IDefaultPool.sol\";\r\nimport \"./IStabilityPoolManager.sol\";\r\n\r\n// Common interface for the Trove Manager.\r\ninterface ITroveManagerHelpers is IDfrancBase {\r\n    enum Status {\r\n        nonExistent,\r\n        active,\r\n        closedByOwner,\r\n        closedByLiquidation,\r\n        closedByRedemption\r\n    }\r\n\r\n    // Store the necessary data for a trove\r\n    struct Trove {\r\n        address asset;\r\n        uint256 debt;\r\n        uint256 coll;\r\n        uint256 stake;\r\n        Status status;\r\n        uint128 arrayIndex;\r\n    }\r\n\r\n    /*\r\n     * --- Variable container structs for liquidations ---\r\n     *\r\n     * These structs are used to hold, return and assign variables inside the liquidation functions,\r\n     * in order to avoid the error: \"CompilerError: Stack too deep\".\r\n     **/\r\n\r\n    struct LocalVariables_OuterLiquidationFunction {\r\n        uint256 price;\r\n        uint256 DCHFInStabPool;\r\n        bool recoveryModeAtStart;\r\n        uint256 liquidatedDebt;\r\n        uint256 liquidatedColl;\r\n    }\r\n\r\n    struct LocalVariables_InnerSingleLiquidateFunction {\r\n        uint256 collToLiquidate;\r\n        uint256 pendingDebtReward;\r\n        uint256 pendingCollReward;\r\n    }\r\n\r\n    struct LocalVariables_LiquidationSequence {\r\n        uint256 remainingDCHFInStabPool;\r\n        uint256 i;\r\n        uint256 ICR;\r\n        address user;\r\n        bool backToNormalMode;\r\n        uint256 entireSystemDebt;\r\n        uint256 entireSystemColl;\r\n    }\r\n\r\n    struct LocalVariables_AssetBorrowerPrice {\r\n        address _asset;\r\n        address _borrower;\r\n        uint256 _price;\r\n    }\r\n\r\n    struct LiquidationValues {\r\n        uint256 entireTroveDebt;\r\n        uint256 entireTroveColl;\r\n        uint256 collGasCompensation;\r\n        uint256 DCHFGasCompensation;\r\n        uint256 debtToOffset;\r\n        uint256 collToSendToSP;\r\n        uint256 debtToRedistribute;\r\n        uint256 collToRedistribute;\r\n        uint256 collSurplus;\r\n    }\r\n\r\n    struct LiquidationTotals {\r\n        uint256 totalCollInSequence;\r\n        uint256 totalDebtInSequence;\r\n        uint256 totalCollGasCompensation;\r\n        uint256 totalDCHFGasCompensation;\r\n        uint256 totalDebtToOffset;\r\n        uint256 totalCollToSendToSP;\r\n        uint256 totalDebtToRedistribute;\r\n        uint256 totalCollToRedistribute;\r\n        uint256 totalCollSurplus;\r\n    }\r\n\r\n    struct ContractsCache {\r\n        IActivePool activePool;\r\n        IDefaultPool defaultPool;\r\n        IDCHFToken dchfToken;\r\n        IMONStaking monStaking;\r\n        ISortedTroves sortedTroves;\r\n        ICollSurplusPool collSurplusPool;\r\n        address gasPoolAddress;\r\n    }\r\n    // --- Variable container structs for redemptions ---\r\n\r\n    struct RedemptionTotals {\r\n        uint256 remainingDCHF;\r\n        uint256 totalDCHFToRedeem;\r\n        uint256 totalAssetDrawn;\r\n        uint256 ETHFee;\r\n        uint256 ETHToSendToRedeemer;\r\n        uint256 decayedBaseRate;\r\n        uint256 price;\r\n        uint256 totalDCHFSupplyAtStart;\r\n    }\r\n\r\n    struct SingleRedemptionValues {\r\n        uint256 DCHFLot;\r\n        uint256 ETHLot;\r\n        bool cancelledPartial;\r\n    }\r\n\r\n    // Object containing the ETH and DCHF snapshots for a given active trove\r\n    struct RewardSnapshot {\r\n        uint256 asset;\r\n        uint256 DCHFDebt;\r\n    }\r\n\r\n    // --- Events ---\r\n\r\n    event Liquidation(\r\n        address indexed _asset,\r\n        uint256 _liquidatedDebt,\r\n        uint256 _liquidatedColl,\r\n        uint256 _collGasCompensation,\r\n        uint256 _DCHFGasCompensation\r\n    );\r\n    event Redemption(\r\n        address indexed _asset,\r\n        uint256 _attemptedDCHFAmount,\r\n        uint256 _actualDCHFAmount,\r\n        uint256 _AssetSent,\r\n        uint256 _AssetFee\r\n    );\r\n    event TroveUpdated(\r\n        address indexed _asset,\r\n        address indexed _borrower,\r\n        uint256 _debt,\r\n        uint256 _coll,\r\n        uint256 stake,\r\n        uint8 operation\r\n    );\r\n    event TroveLiquidated(\r\n        address indexed _asset,\r\n        address indexed _borrower,\r\n        uint256 _debt,\r\n        uint256 _coll,\r\n        uint8 operation\r\n    );\r\n    event BaseRateUpdated(address indexed _asset, uint256 _baseRate);\r\n    event LastFeeOpTimeUpdated(address indexed _asset, uint256 _lastFeeOpTime);\r\n    event TotalStakesUpdated(address indexed _asset, uint256 _newTotalStakes);\r\n    event SystemSnapshotsUpdated(\r\n        address indexed _asset,\r\n        uint256 _totalStakesSnapshot,\r\n        uint256 _totalCollateralSnapshot\r\n    );\r\n    event LTermsUpdated(\r\n        address indexed _asset,\r\n        uint256 _L_ETH,\r\n        uint256 _L_DCHFDebt\r\n    );\r\n    event TroveSnapshotsUpdated(\r\n        address indexed _asset,\r\n        uint256 _L_ETH,\r\n        uint256 _L_DCHFDebt\r\n    );\r\n    event TroveIndexUpdated(\r\n        address indexed _asset,\r\n        address _borrower,\r\n        uint256 _newIndex\r\n    );\r\n\r\n    event TroveUpdated(\r\n        address indexed _asset,\r\n        address indexed _borrower,\r\n        uint256 _debt,\r\n        uint256 _coll,\r\n        uint256 _stake,\r\n        TroveManagerOperation _operation\r\n    );\r\n    event TroveLiquidated(\r\n        address indexed _asset,\r\n        address indexed _borrower,\r\n        uint256 _debt,\r\n        uint256 _coll,\r\n        TroveManagerOperation _operation\r\n    );\r\n\r\n    enum TroveManagerOperation {\r\n        applyPendingRewards,\r\n        liquidateInNormalMode,\r\n        liquidateInRecoveryMode,\r\n        redeemCollateral\r\n    }\r\n\r\n    // Functions\r\n\r\n    function addTroveOwnerToArray(address _asset, address _borrower)\r\n        external\r\n        returns (uint256 index);\r\n\r\n    function applyPendingRewards(address _asset, address _borrower) external;\r\n\r\n    function checkRecoveryMode(address _asset, uint256 _price)\r\n        external\r\n        returns (bool);\r\n\r\n    function closeTrove(address _asset, address _borrower) external;\r\n\r\n    function decayBaseRateFromBorrowing(address _asset) external;\r\n\r\n    function decreaseTroveColl(\r\n        address _asset,\r\n        address _borrower,\r\n        uint256 _collDecrease\r\n    ) external returns (uint256);\r\n\r\n    function decreaseTroveDebt(\r\n        address _asset,\r\n        address _borrower,\r\n        uint256 _collDecrease\r\n    ) external returns (uint256);\r\n\r\n    function getBorrowingFee(address _asset, uint256 DCHFDebt)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getBorrowingRateWithDecay(address _asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getBorrowingRate(address _asset) external view returns (uint256);\r\n\r\n    function getCurrentICR(\r\n        address _asset,\r\n        address _borrower,\r\n        uint256 _price\r\n    ) external view returns (uint256);\r\n\r\n    function getEntireDebtAndColl(address _asset, address _borrower)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 debt,\r\n            uint256 coll,\r\n            uint256 pendingDCHFDebtReward,\r\n            uint256 pendingAssetReward\r\n        );\r\n\r\n    function getNominalICR(address _asset, address _borrower)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getPendingAssetReward(address _asset, address _borrower)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getPendingDCHFDebtReward(address _asset, address _borrower)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getRedemptionFeeWithDecay(address _asset, uint256 _assetDraw)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getRedemptionRate(address _asset) external view returns (uint256);\r\n\r\n    function getRedemptionRateWithDecay(address _asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTCR(address _asset, uint256 _price)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTroveColl(address _asset, address _borrower)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTroveDebt(address _asset, address _borrower)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTroveStake(address _asset, address _borrower)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTroveStatus(address _asset, address _borrower)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function hasPendingRewards(address _asset, address _borrower)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function increaseTroveColl(\r\n        address _asset,\r\n        address _borrower,\r\n        uint256 _collIncrease\r\n    ) external returns (uint256);\r\n\r\n    function increaseTroveDebt(\r\n        address _asset,\r\n        address _borrower,\r\n        uint256 _debtIncrease\r\n    ) external returns (uint256);\r\n\r\n    function setTroveStatus(\r\n        address _asset,\r\n        address _borrower,\r\n        uint256 num\r\n    ) external;\r\n\r\n    function updateTroveRewardSnapshots(address _asset, address _borrower)\r\n        external;\r\n\r\n    function getBorrowingFeeWithDecay(address _asset, uint256 _DCHFDebt)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTroveOwnersCount(address _asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTroveFromTroveOwnersArray(address _asset, uint256 _index)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function setTroveDeptAndColl(\r\n        address _asset,\r\n        address _borrower,\r\n        uint256 _debt,\r\n        uint256 _coll\r\n    ) external;\r\n\r\n    function isTroveActive(address _asset, address _borrower)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function movePendingTroveRewardsToActivePool(\r\n        address _asset,\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        uint256 _DCHF,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    function removeStake(address _asset, address _borrower) external;\r\n\r\n    function closeTrove(\r\n        // access control\r\n        address _asset,\r\n        address _borrower,\r\n        Status closedStatus\r\n    ) external;\r\n\r\n    function redistributeDebtAndColl(\r\n        address _asset,\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        uint256 _debt,\r\n        uint256 _coll\r\n    ) external;\r\n\r\n    function updateSystemSnapshots_excludeCollRemainder(\r\n        // access control\r\n        address _asset,\r\n        IActivePool _activePool,\r\n        uint256 _collRemainder\r\n    ) external;\r\n\r\n    function _checkPotentialRecoveryMode(\r\n        // access control\r\n        address _asset,\r\n        uint256 _entireSystemColl,\r\n        uint256 _entireSystemDebt,\r\n        uint256 _price\r\n    ) external view returns (bool);\r\n\r\n    function updateBaseRateFromRedemption(\r\n        address _asset,\r\n        uint256 _ETHDrawn,\r\n        uint256 _price,\r\n        uint256 _totalDCHFSupply\r\n    ) external returns (uint256);\r\n\r\n    function updateStakeAndTotalStakes(address _asset, address _borrower)\r\n        external\r\n        returns (uint256);\r\n\r\n    function _requireValidMaxFeePercentage(\r\n        address _asset,\r\n        uint256 _maxFeePercentage\r\n    ) external view;\r\n\r\n    function _requireTCRoverMCR(address _asset, uint256 _price) external view;\r\n\r\n    function _requireAmountGreaterThanZero(uint256 _amount) external pure;\r\n\r\n    function _requireDCHFBalanceCoversRedemption(\r\n        IDCHFToken _dchfToken,\r\n        address _redeemer,\r\n        uint256 _amount\r\n    ) external view;\r\n\r\n    function applyPendingRewards(\r\n        address _asset,\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        address _borrower\r\n    ) external;\r\n\r\n    function _getRedemptionFee(address _asset, uint256 _assetDraw)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTrove(address _asset, address _borrower)\r\n        external\r\n        view\r\n        returns (\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            Status,\r\n            uint128\r\n        );\r\n\r\n    function getRewardSnapshots(address _asset, address _troveOwner)\r\n        external\r\n        view\r\n        returns (uint256 asset, uint256 DCHFDebt);\r\n}\r\n"
    },
    "contracts/HarvestaStaking.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./defifranc/interfaces/IBorrowerOperations.sol\";\nimport \"./defifranc/interfaces/ITroveManagerHelpers.sol\";\nimport \"./defifranc/interfaces/IHintHelpers.sol\";\nimport \"./defifranc/interfaces/IDCHFToken.sol\";\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\n\nerror HarvestaStaking__NotEnoughEther();\nerror HarvestaStaking__TroveIsActive();\nerror HarvestaStaking__TroveIsNotActive();\nerror HarvestaStaking__SenderIsNotYieldManager();\n\ncontract HarvestaStaking {\n    using SafeMath for uint256;\n\n    /* ====== DEFIFRANC Contracts ====== */\n\n    IBorrowerOperations public borrowerOperations;\n    IHintHelpers public hintHelpers;\n    ITroveManagerHelpers public troveManagerHelper;\n\n    /* ====== State Variables ====== */\n\n    address private yieldManagerAddress;\n\n    mapping(address => uint256) private totalStakedAssets;\n\n    /* ====== Modifiers ====== */\n\n    modifier hasNoTrove(address _asset) {\n        bool _active = troveManagerHelper.isTroveActive(_asset, address(this));\n        if (_active) {\n            revert HarvestaStaking__TroveIsActive();\n        }\n        _;\n    }\n\n    modifier isTroveActive(address _asset) {\n        bool _active = troveManagerHelper.isTroveActive(_asset, address(this));\n        if (!_active) {\n            revert HarvestaStaking__TroveIsNotActive();\n        }\n        _;\n    }\n\n    modifier isYieldManager() {\n        if (msg.sender != yieldManagerAddress) {\n            revert HarvestaStaking__SenderIsNotYieldManager();\n        }\n        _;\n    }\n\n    // Function to receive Ether. msg.data must be empty\n    receive() external payable {}\n\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n\n    constructor(\n        address _borrowerOperations,\n        address _hintHelpers,\n        address _troveManagerHelpers\n    ) {\n        borrowerOperations = IBorrowerOperations(_borrowerOperations);\n\n        hintHelpers = IHintHelpers(_hintHelpers);\n\n        troveManagerHelper = ITroveManagerHelpers(_troveManagerHelpers);\n    }\n\n    function openTroveWithHint(\n        address _asset,\n        uint256 _collEther,\n        uint256 _amountDebt\n    ) external hasNoTrove(_asset) {}\n\n    function adjustTroveWithHint() external isYieldManager {}\n\n    function openTrove(\n        address _asset,\n        uint256 _collEther,\n        uint256 _amountDebt\n    ) external hasNoTrove(_asset) {\n        uint256 _maxFee = 5e16;\n\n        _openTrove(\n            _asset,\n            _maxFee,\n            _amountDebt,\n            _collEther,\n            address(this),\n            address(this)\n        );\n    }\n\n    function _openTrove(\n        address _asset,\n        uint256 _maxFee,\n        uint256 _amountDebt,\n        uint256 _collEther,\n        address _upperHint,\n        address _lowerHint\n    ) internal {\n        if (_collEther > getBalance()) {\n            revert HarvestaStaking__NotEnoughEther();\n        }\n        if (_asset == address(0)) {\n            borrowerOperations.openTrove{value: _collEther}(\n                _asset,\n                _collEther,\n                _maxFee,\n                _amountDebt,\n                _upperHint,\n                _lowerHint\n            );\n        }\n    }\n\n    function adjustTrove(\n        address _asset,\n        uint256 _assetSent,\n        uint256 _maxFee,\n        uint256 _collWithdrawal,\n        uint256 _debtChange,\n        bool isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    ) internal {}\n\n    function getBalance() internal view returns (uint256) {\n        return address(this).balance;\n    }\n}\n"
    },
    "contracts/HarvestaYieldManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\nimport \"./defifranc/interfaces/IStabilityPool.sol\";\r\nimport \"./defifranc/interfaces/IStabilityPoolManager.sol\";\r\nimport \"./defifranc/interfaces/IDCHFToken.sol\";\r\nimport \"./defifranc/interfaces/IPriceFeed.sol\";\r\nimport \"./HarvestaStaking.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\ncontract HarvestaYieldManager {\r\n    using SafeCast for int;\r\n    using SafeCast for uint256;\r\n    using SafeMath for uint256;\r\n\r\n    /* ====== DEFIFRANC CONTRACTS ====== */\r\n    IDCHFToken public DCHFToken;\r\n    IPriceFeed public priceFeed;\r\n    IStabilityPoolManager public stabilityPoolManager;\r\n\r\n    /* ====== State Variables ====== */\r\n    uint256 private reservePool;\r\n    uint256 private rewardPool;\r\n\r\n    mapping(address => IStabilityPool) private stabilityPoolAddresses;\r\n\r\n    /* ====== Events ====== */\r\n    event UpdateDCHFDeposit(uint256 totalDeposit, uint256 amountSent);\r\n\r\n    constructor(address _DCHFTokenAddress, address _stabilityPoolManagerAddress)\r\n    {\r\n        DCHFToken = IDCHFToken(_DCHFTokenAddress);\r\n        stabilityPoolManager = IStabilityPoolManager(\r\n            _stabilityPoolManagerAddress\r\n        );\r\n\r\n        //implement the priceFeed and stabilityPool for Ether\r\n        address zeroAddress = address(0);\r\n        stabilityPoolAddresses[zeroAddress] = stabilityPoolManager\r\n            .getAssetStabilityPool(address(0));\r\n    }\r\n\r\n    /* ====== Functions ====== */\r\n\r\n    /* ====== Internal Functions ====== */\r\n\r\n    function _transferAvailableTokensToStabilityPool(address _asset) public {\r\n        uint256 _balance = DCHFToken.balanceOf(address(this));\r\n\r\n        IStabilityPool pool = stabilityPoolAddresses[_asset];\r\n\r\n        pool.provideToSP(_balance);\r\n    }\r\n\r\n    /* ====== View / Pure Functions ====== */\r\n\r\n    function fetchAssetPrice(address _asset) public view returns (uint256) {\r\n        uint256 _price = priceFeed.getDirectPrice(_asset);\r\n\r\n        return _price;\r\n    }\r\n\r\n    /**\r\n     * TODO:\r\n     *  1. Fetch for the actual asset price via ChainLink PriceFeed\r\n     *  2. Check the current ICR of the stakingContract\r\n     *  3. Adjust the trove, if the ICR out of the range\r\n     *  4. Implement ChainLink Keeper and automate the check\r\n     *  5. Only adjust the trove every 24h or rescue operation\r\n     *  6. Implement a overview of all troves and check for liquidation\r\n     *  7. Automate the liquidate process\r\n     * 8. After Liquidation fill the Emergency Trove with the assets\r\n     * 9. Add the DCHF to the stability pool\r\n     */\r\n}\r\n"
    },
    "contracts/token/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\n\r\ninterface IERC2612Permit {\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\r\n     * given `owner`'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n}\r\n\r\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\r\n    using Counters for Counters.Counter;\r\n\r\n    mapping(address => Counters.Counter) private _nonces;\r\n\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n\r\n    constructor() {\r\n        uint256 chainID;\r\n        assembly {\r\n            chainID := chainid()\r\n        }\r\n\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\r\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n                ),\r\n                keccak256(bytes(name())),\r\n                keccak256(bytes(\"1\")), // Version\r\n                chainID,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC2612Permit-permit}.\r\n     *\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external virtual override {\r\n        require(block.timestamp <= deadline, \"Permit: expired deadline\");\r\n\r\n        bytes32 hashStruct = keccak256(\r\n            abi.encode(\r\n                PERMIT_TYPEHASH,\r\n                owner,\r\n                spender,\r\n                amount,\r\n                _nonces[owner].current(),\r\n                deadline\r\n            )\r\n        );\r\n\r\n        bytes32 _hash = keccak256(\r\n            abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct)\r\n        );\r\n\r\n        address signer = ecrecover(_hash, v, r, s);\r\n        require(\r\n            signer != address(0) && signer == owner,\r\n            \"ERC20Permit: Invalid signature\"\r\n        );\r\n\r\n        _nonces[owner].increment();\r\n        _approve(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC2612Permit-nonces}.\r\n     */\r\n    function nonces(address owner) public view override returns (uint256) {\r\n        return _nonces[owner].current();\r\n    }\r\n\r\n    function chainId() public view returns (uint256 chainID) {\r\n        assembly {\r\n            chainID := chainid()\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}